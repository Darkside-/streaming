<!DOCTYPE html>
<!-- saved from url=(0047)http://mtgbot.tv/overlay/?username=heffaklumpen -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>MTGBot Status</title>

    <style type="text/css">
        * {
            padding: 0;
            margin: 0;
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
        }

        body {
            overflow: visible !important;
            margin: 0 !important;
        }

        #status {
            overflow: hidden;
            width: 415px;
            height: 99px;
        }

        .text {
            -webkit-font-smoothing: antialiased;
            position: absolute;
            color: #ffffff;
            font-family: 'DIN 1451 Std Engschrift';
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #statustext {
            top: 20px;
            left: 155px;
            width: 220px;
            font-size: 22px;
            font-family: 'DIN 1451 Std Engschrift';
            text-align: center;
        }

        #decktext {
            top: 65px;
            left: 150px;
            font-size: 12px;
            font-family: 'DIN 1451 Std Engschrift'
        }

        #tourntext {
            top: 75px;
            left: 150px;
            font-size: 16px;
            width: 160px;
        }

        #recordtext {
            top: 60px;
            left: 320px;
            text-align: right;
            width: 40px;
            font-size: 35px;
        }

        #background {
            position: absolute;
            width: 415px;
            height: 99px;
            background: url('images/background.png') no-repeat;
            clip: rect(50px 415px 50px 0px);
        }

        #background-border {
            position: absolute;
            overflow: hidden;
            width: 415px;
            height: 99px;
            -webkit-clip-path: polygon(37px 99px,365px 98px,415px 0px,37px 0px,0px 49px);
            z-index: 50;
        }

        #booster1,
        #booster2,
        #booster3 {
            width: 56px;
            height: 80px;
            background-size: cover;
            position: relative;
            opacity: 0;
            /*-webkit-box-shadow: -5px 5px 5px 0px rgba(0, 0, 0, 0.38);
            -moz-box-shadow: -5px 5px 5px 0px rgba(0, 0, 0, 0.38);
            box-shadow: -5px 5px 5px 0px rgba(0, 0, 0, 0.38);*/
        }

        #booster1 {
            background-image: url('images/booster1.png');
            left: 12px;
            top: 30px;
            z-index: 1;
            transform: translate3d(0, 0, 0) rotate(-15deg);
        }

        #booster2 {
            background-image: url('images/booster2.png');
            left: 50px;
            top: -55px;
            z-index: 2;
            transform: translate3d(0, 0, 0) rotate(0deg);
        }

        #booster3 {
            background-image: url('images/booster3.png');
            left: 85px;
            top: -130px;
            z-index: 3;
            transform: translate3d(0, 0, 0) rotate(15deg);
        }

        #status object {
            position: absolute;
            top: 0;
            left: 0;
        }

        .image {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            background-repeat: no-repeat;
            height: 99px;
            width: 155px;
        }

        #updown {
            position: absolute;
            width: 11px;
            height: 15px;
            top: 72px;
            left: 310px;
        }

        #updown.up {
            background-image: url('images/up.png');

        }

        #updown.down {
            background-image: url('images/down.png');

        }

        svg {
            position: absolute;
            top: 0;
            left: 0;
        }
        svg path, svg polygon, svg polyline {
            stroke-dasharray: 0, 100%;
        }

        html {
            text-rendering: optimizeLegibility !important;
            -webkit-font-smoothing: antialiased !important;
        }
    </style>

    <link rel="stylesheet" type="text/css" href="./MTGBot Status_files/fonts-new2.css">
</head>

<body>
<div id="status">
    <div id="background">
        <div id="background-border">
            <div id="booster1"></div>
            <div id="booster2"></div>
            <div id="booster3"></div>
            <div id="statustext" class="text"></div>
            <div id="decktext" class="text"></div>
            <div id="tourntext" class="text"></div>
            <div id="recordtext" class="text"></div>
            <div id="updown"></div>
        </div>
    </div>
</div>

<script type="text/javascript" src="./MTGBot Status_files/TweenMax.min.js.download"></script>
<script type="text/javascript" src="./MTGBot Status_files/TimelineMax.min.js.download"></script>
<script type="text/javascript" src="./MTGBot Status_files/jquery-3.2.1.min.js.download"></script>
<script type="text/javascript" src="./MTGBot Status_files/jquery.signalR-2.2.0.min.js.download"></script>
<script type="text/javascript" src="./MTGBot Status_files/hubs"></script>
<script type="text/javascript" src="./MTGBot Status_files/linq.min.js.download"></script>
<script type="text/javascript" src="./MTGBot Status_files/DrawSVGPlugin.min.js.download"></script>

<script type="text/javascript">

    function getQueryParams(qs) {
        qs = qs.split("+").join(" ");
        var params = {},
                tokens,
                re = /[?&]?([^=]+)=([^&]*)/g;

        while (tokens = re.exec(qs)) {
            params[decodeURIComponent(tokens[1])]
                    = decodeURIComponent(tokens[2]);
        }

        return params;
    }

    $get = getQueryParams(document.location.search);
</script>

<script type="text/javascript">

    var Status = function() {
        var bg = $('#background'),
                booster1 = $('#booster1'),
                booster2 = $('#booster2'),
                booster3 = $('#booster3');

        var mainTimeline = new TimelineMax({autoRemoveChildren: true});

        var tournaments = {};

        //currentTournament
        var ct = null;
        var boosterInterval = null;
        var isOpen = false;
        var timeOffset = 0;

        //Check for double queues, and switch between them
/*        setInterval(function() {
            if ( ct != null ) {
                var anotherTournament = Enumerable.From(tournaments)
                        .OrderBy(function(t) {
                            return new Date(t.Value.startDate.valueOf())
                        })
                        .FirstOrDefault(null, function(t) {
							var dt = new Date(t.Value.startDate.valueOf());
							
                            return !t.Value.isEliminiated && !t.Value.isCompleted && t.Value.id != tournaments[ct].id && dt.getTime() < new Date().getTime() + 60 * 10 * 1000;
                        });

                if ( anotherTournament != null )
                {
                    var at = anotherTournament.Key;
                    console.log('Switching to: ', anotherTournament.Value);

                    if ( tournaments[ct].format != tournaments[at].format ) {
                        clearText();
                        closeFormat();
                        mainTimeline.add(function() {
                            ct = at;
                        }).play();
                        openFormat(tournaments[at].format, true);
                    } else {
                        mainTimeline.add(function() {
                            ct = at;
                        });
                    }

                    mainTimeline.add(updateText).play();
                } else {
                    console.log('No tournament to switch to.')
                }
            }
        }, ($get.debug ? 20 : 60) * 1000);
*/
        var timers = {
            init: function() {
                setInterval(function () {
                    $('.countdown').each(function () {
                        $(this).text(timers.getFormatted($(this).data('to')));
                    });
                }, 1000);
            },
            getFormatted: function(dt) {
                var seconds = Math.floor(((new Date(dt) - new Date()) + timeOffset) / 1000);

                if (seconds > 1) {
                    var format = "";
                    if (seconds >= 60) {
                        format += " " + Math.floor(seconds / 60) + " minute";
                        if (seconds > 120)
                            format += "s";
                    }

                    seconds = seconds % 60;

                    format += " " + seconds + " second";

                    if (seconds !== 1)
                        format += "s";

                    return 'in: ' + format;
                }
                else {
                    return 'shortly';
                }
            }
        };

        var open = function() {
            var skewTimeline = new TimelineLite();

            skewTimeline.fromTo(bg, 1, {clip:'rect(50px 415px 50px 0px);', opacity: 0}, {clip:'rect(0px 415px 99px 0px);', opacity: 1});

            skewTimeline.eventCallback('onComplete', function() {
                $(bg).css({'clip': 'auto'});
            });

            mainTimeline.add(skewTimeline);
        }

        var close = function() {
			setTimeout(function() {
				console.log('Checking to see if we still need to close', ct);
				if ( ct != null || !isOpen )
					return;

				isOpen = false;
				clearText();
				closeFormat();

				var skewTimeline = new TimelineLite();

				skewTimeline.fromTo(bg, 1, {clip:'rect(0px 415px 99px 0px);', opacity: 1}, {clip:'rect(50px 415px 50px 0px);', opacity: 0});

				mainTimeline.add(skewTimeline);
			}, 2000);
        }

        var openFormat = function(what, quick) {
            console.log('openFormat(', what, ',', quick, ')');
            what = what.toLowerCase();
            quick = quick || false;

            var image = function(what, pct) {
                pct = pct || 100
                var tl = new TimelineMax();
				
				console.log('openImage(', what, ',', pct, ')');
				tl.add(function() {
					console.log('Opening Image');
				}).play();
				
				tl.fromTo('#' + what + '-image', 2, {opacity: 0}, {opacity: 1});
				
                tl.add(function() {
                    $('#' + what + '-image').addClass('open');
                }).play();

                return tl;
            }
			
            var pct;
			
            switch (what) {
                case 'vintage':
                case 'legacy':
                    pct = 35;
                case 'modern':
                case 'pauper':
                case 'standard':
				case 'cmdr1v1':
                    mainTimeline.add(image(what, pct));
                    break;
				case '1xc06':
                    mainTimeline.add(image('special', pct));
					break;
                default:
                    if ( what.match(/^(6[a-z]{3}|4[a-z]{3}2[a-z]{3}|2[a-z]{3}4[a-z]{3}|(2[a-z]{3}){3})$/i) )
                    {
                        mainTimeline.add(image('sealed'));
                        break;
                    }

                    var tl = new TimelineMax();
					
					tl.add(function() {
						boosterInterval = setInterval(function() {
							var boostTimeline = new TimelineLite();

							boostTimeline.to(booster2, 2, {rotationY: "+=360"});
							boostTimeline.to(booster2, 0.8, {top: "-65px"}, 0);
							boostTimeline.to(booster2, 0.8, {top: "-55px"}, 0.8);

							mainTimeline.add(boostTimeline);
						}, 5 * 60 * 1000);
					}).play();
					
					var len = (what.length == 6) ? 2 : 3;
					
					booster1.css('background-image', 'url(http://www.mtgbot.tv/api/mtgo/booster/' + what.substr(0, len) + ')');
					booster2.css('background-image', 'url(http://www.mtgbot.tv/api/mtgo/booster/' + what.substr(len, len) + ')');
					booster3.css('background-image', 'url(http://www.mtgbot.tv/api/mtgo/booster/' + what.substr(len*2, len) + ')');
				
					tl.fromTo(booster1, 0.6, {top: '130px'}, {top: '30px', ease:Back.easeOut}, 0);
					tl.fromTo(booster2, 0.6, {top:'45px'}, {top: '-55px', ease:Back.easeOut}, 0.2);
					tl.fromTo(booster3, 0.6, {top: '-30px'}, {top: '-130px', ease:Back.easeOut}, 0.4);
					tl.to([booster1, booster2, booster3], 0, {opacity:1}, 0);
					mainTimeline.add(tl);
                    break;
            }
        }

        var closeFormat = function() {

            console.log('Closing Format', $('div.open').length);
            var tl = new TimelineMax();
			
			tl.add(function() {
				if ( boosterInterval != null ) {
					clearInterval(boosterInterval);
					boosterInterval = null;
				}
			}).play();

			tl.to(booster1, 0.6, {top: '130px', ease:Back.easeOut}, 0);
			tl.to(booster2, 0.6, {top: '45px', ease:Back.easeOut}, 0.2);
			tl.to(booster3, 0.6, {top: '-30px', ease:Back.easeOut}, 0.4);

			tl.to('.open', 2, {opacity: 0}, 0);
			tl.add(function() {
				$('.open').removeClass('open');
			}).play();
            

            mainTimeline.add(tl);
        }

        var updateText = function() {
			console.log('update text start');
            if ( ct == null )
                return;

            var tl = new TimelineMax();
            console.log('updateText()', 'Status: ' + tournaments[ct].currentState);
            console.dir(ct);

            if ( $('#tourntext').text() == "" ) {
				tl.fromTo(['#statustext', '#tourntext', '#recordtext', '#updown'], 2, {opacity: 0, ease: Power1.easeOut}, {opacity: 1});
                mainTimeline.add(tl);
            }

            $('#recordtext').text(tournaments[ct].currentRecord);
            $('#tourntext').text(tournaments[ct].descriptionShort.slice(0, -6));
			
			console.log(tournaments[ct].currentRecord);
			
            var state = tournaments[ct].currentState;

            state = state.replace(/{countdown\|([^}]+)}/g, function(wholeMatch, subMatch) {
                return '<span data-to="' + subMatch + '" class="countdown">' + timers.getFormatted(subMatch) + '</span>';
            });

            if ( tournaments[ct].currentGame != 0 ) {
                if ( tournaments[ct].gameWins > tournaments[ct].gameLosses ) {
                    $('#updown').addClass('up').removeClass('down');
                } else if ( tournaments[ct].gameWins < tournaments[ct].gameLosses ) {
                    $('#updown').addClass('down').removeClass('up');
                } else {
                    $('#updown').removeClass('up down');
                }
            } else {
                $('#updown').removeClass('up down');
            }

            $('#statustext').html(state);
			console.log('update text complete');
        }

        var clearText = function() {
            var tl = new TimelineMax();

			tl.fromTo(['#statustext', '#tourntext', '#recordtext', '#updown'], 2, {opacity: 1, ease: Power1.easeOut}, {opacity: 0});
			
            tl.add(function() {
                $('#recordtext, #tourntext, #statustext').empty();
                $('#updown').removeClass('up down');
            }).play();

            mainTimeline.add(tl);
        }

         * Main update function for handling what to do when a tournament gets updated
         */
        var update = function() {
            //Check to see if the current tournament is done, or we don't have one:
            if ( ct == null || tournaments[ct].isEliminiated || tournaments[ct].isCompleted ) {
				console.log("ct:", ct);
				
				if ( ct != null )
				{
					console.dir(tournaments[ct]);
				}
				
				ct = null;
				
                var nt = Enumerable.From(tournaments)
                        .OrderBy(function(t) {
                            return new Date(t.Value.startDate.valueOf())
                        })
                        .FirstOrDefault(null, function(t) {
							var dt = new Date(t.Value.startDate.valueOf());
                            return !t.Value.isEliminiated && !t.Value.isCompleted && dt.getTime() < new Date().getTime() + 60 * 10 * 1000;
                        });

                if ( nt == null && isOpen ) {
                    console.log('Current tournament null; closing.');
					close();
                    return;
                } else if ( nt == null ) {
                    console.log('Current tournament null.');
                    return;
                }
				
				var ot = ct;
                var at = nt.Key;

                if ( !isOpen )
                {
					ct = at;
                    open()
                    //openFormat(tournaments[ct].format);
                    isOpen = true;
                }
				else if ( tournaments[ct].format != tournaments[at].format ) {
					clearText();
					closeFormat();
					mainTimeline.add(function() {
						ct = at;
					}).play();
					//openFormat(tournaments[at].format, true);
				}
				else {
					ct = at;
				}

                mainTimeline.add(updateText).play();
            }
            else if ( ct != null )
            {
                mainTimeline.add(updateText).play();
            }
        }

        this.run = function() {
            $.connection.hub.url = "http://mtgbot.tv/signalr";
			
            $.connection.hub.qs = {username: 'thundermo_hellkite'};

            $.connection.hub.disconnected(function() {
                setTimeout(function() {
                    $.connection.hub.start();
                }, 5000); // Restart connection after 5 seconds.
            });

            var hub = $.connection.tournamentHub;

            hub.client.updateTournament = function (tournament) {
                if ( $get.debug ) {
                    console.groupCollapsed('Update tournaments:')

                    console.dir(tournament);
                }

                if ( $.isArray(tournament) ) {
					tournaments = {};
                    $.each(tournament, function(idx, tourn) {
                        tournaments[tourn.id] = tourn;
                    });
                } else {
                    tournaments[tournament.id] = tournament;
                }

                if ( $get.debug ) {
                    $.each(tournaments, function(key, val) {
                        console.group(val.descriptionShort);
                        console.log('ID=', val.id);
                        console.log('Status=', val.currentState, ', Eliminated=', val.isEliminiated, ', Completed=', val.isCompleted);
                        console.groupEnd();
                    });
                    console.groupEnd();
                }

                update();
            };

            hub.client.syncTime = function(dt) {
                //When the client connects, the server will send down one syncTime with the current
                //datetime of the server. This will sync the countdowns to the correct times.
                timeOffset = new Date()-new Date(dt);
                console.log('Updating time offset: ', timeOffset);
            };
			
			hub.client.refresh = function() {
				window.location.reload(true);
			};

            $.connection.hub.start().done(function () {
            });
            timers.init();
        }
    }


    $(window).on('load', function() {


        window.mainStatus = new Status();

        mainStatus.run();

        /*function image(what, pct) {
         var pct = pct || 100
         var tl = new TimelineMax();

         tl.fromTo($('#' + what + '-outline path, #' + what + '-outline polygon, #' + what + '-outline polyline'), 4, {drawSVG:"%"}, {drawSVG: pct + "%", ease: Power1.easeInOut}, 0.1);
         tl.to('#' + what + '-image', 2, {opacity: 1});
         tl.to('#' + what + '-outline', 1, {opacity: 0}, 5);
         }

         function boosters() {
         var tl = new TimelineLite();

         tl.staggerFrom([booster1, booster2, booster3], 0.6, {left:"-=200px", rotation: "-=50", ease:Back.easeOut}, 0.2)
         .to([booster1, booster2, booster3], 0, {opacity:1}, 0);

         setInterval(function() {
         TweenMax.to(booster2, 2, {rotationY: "+=360"})
         TweenMax.to(booster2, 0.8, {top: "-65px"}).eventCallback('onComplete', function() {
         this.reverse();
         })
         }, 20 * 1000);
         }

         open().eventCallback('onComplete', function() {
         $(bg).css({'clip': 'auto'});
         boosters();
         //image('legacy');
         //image('modern', 90);
         //image('pauper');
         //image('sealed');
         //image('standard');
         //image('vintage');

         }).play();*/
    });
</script>
<!--
<script>
$(window).load(function() {
	/*var skew = $("#skew"),
		logos = $(".logo"),
		dotContainer = $("#dotContainer"),
		skewBtn = $("#skewBtn"),
		staggerBtn = $("#staggerBtn"),
		particlesBtn = $("#particlesBtn"), 
		tl = new TimelineLite();*/
		
	var bg = $('#background'),
		booster1 = $('#booster1'),
		booster2 = $('#booster2'),
		booster3 = $('#booster3');
	
	function open() {
		var skewTimeline = new TimelineLite({paused: true});
		/*skewTimeline.from(bg, 0.3, {alpha:0})
					.to(bg, 0.5, {skewX:45})
					.to(bg, 0.8, {skewX:-45})
					.to(bg, 0.5, {skewX:5, skewY:-10})
					.to(bg, 0.5, {skewX:20, skewY:5})
					.to(bg, 0.5, {alpha:0});*/
					
		/*var from = [50, 50];
		var to = [0, 100];
		
		to.onUpdate = function() {
			console.log(from);
			TweenMax.set('#background', {
				'webkitClipPath': 'polygon(0px ' + from[0] + '%, 100% ' + from[0] + '%, 100% ' + from[1] + '%, 0px ' + from[1] + '%)'
			});
		}
		
		skewTimeline.to(from, 2, to);*/
		
		skewTimeline.to(bg, 1, {clip:'rect(0px 415px 99px 0px);'});
		return skewTimeline;
	}
	
	function boosters() {
		var tl = new TimelineLite(),
			tl1 = new TimelineLite(),
			tl2 = new TimelineLite(),
			tl3 = new TimelineLite();
		
		tl1.staggerFrom(booster1, 0.6, {left:"-=200px", rotation:"-50deg", ease:Back.easeOut}, 0.1)
					   .to(booster1, 0, {opacity:1});
		
		tl2.staggerFrom(booster2, 0.6, {left:"-=200px", rotation:"-50deg", ease:Back.easeOut}, 0.1)
					   .to(booster2, 0, {opacity:1});
					   
		tl3.staggerFrom(booster3, 0.6, {left:"-=200px", rotation:"-50deg", ease:Back.easeOut}, 0.1)
			.to(booster3, 0, {opacity:1});
			
		setInterval(function() {
			TweenMax.to(booster2, 2, {rotationY: "+=360"})
			TweenMax.to(booster2, 0.8, {top: "-65px"}).eventCallback('onComplete', function() {
				this.reverse();
			})
		}, 10 * 1000);
			
		tl.add(tl1)
			.add(tl2, 0.2)
			.add(tl3, 0.5);
		
	}
	
	open().eventCallback('onComplete', function() {
		$(bg).css({'clip': 'auto'});
		boosters();
	}).play();

	
	
	//tl.play("skew");
	return;
	
	//show the demoBackground div after DOM is ready and all images loaded
	/*TweenLite.set($("#demoBackground"), {visibility:"visible"});*/
	// functions for building nested timelines
	
	function getSkewAnimation() {
		var skewTimeline = new TimelineLite();
		skewTimeline.from(skew, 0.3, {alpha:0})
					.to(skew, 0.5, {skewX:45})
					.to(skew, 0.8, {skewX:-45})
					.to(skew, 0.5, {skewX:5, skewY:-10})
					.to(skew, 0.5, {skewX:20, skewY:5})
					.to(skew, 0.5, {alpha:0});
		return skewTimeline;		
	}
	
	function getStaggerAnimation() {
		var staggerTimeline = new TimelineLite();		
		staggerTimeline.from(logos, 0.2, {opacity:0})
					   .staggerFrom(logos, 0.6, {top:-60, left:"-=50px", rotation:"-90deg", ease:Back.easeOut}, 0.1)
					   .to(logos, 1, {opacity:0});
		return staggerTimeline;
	}
	
	function getParticlesAnimation() {
		var particlesTimeline = new TimelineLite(),
			i = 300,
			radius = 450,
			centerX= 360,
			centerY = 30,
			dots = [],
			rawDots = [];
			
		while (--i > -1) {
			dot = document.createElement("img");
			dot.src = "img/dot.png";
			dot.id = "dot" + i;
			dotContainer.append(dot);
			dot.style.cssText = "position:absolute; left:" + centerX + "px; top:" + centerY + "px; width:1px; height:1px;"
			var angle = Math.random() * Math.PI * 2,
				insertionTime = i * 0.015;
				
			particlesTimeline.from(dot, 0.05, {opacity:0, immediateRender:true}, insertionTime);
			
			particlesTimeline.to(dot, .7, {left:Math.cos(angle) * radius + centerX, 
					top:Math.sin(angle) * radius + centerY, 
					width:32, 
					height:32,
				ease:Cubic.easeIn
			}, insertionTime);
			
		}
		return particlesTimeline;
	}		 	

	// build timeline
	
	/*tl.add("skew") // adds a new label
	  .add( getSkewAnimation() ) // method returns a TimelineLite instance that gets nested at the end
	  .add( getStaggerAnimation(), "stagger") //creates new label and adds animation there
	  .add( getParticlesAnimation(), "particles")
		
	
	//show the demoBackground div after DOM is ready and all images loaded
	TweenLite.set($("#demoBackground"), {visibility:"visible"});*/
});
</script>
-->


</body></html>